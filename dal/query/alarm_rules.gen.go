// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"test/book/dal/model"
)

func newAlarmRulesDO(db *gorm.DB, opts ...gen.DOOption) alarmRulesDO {
	_alarmRulesDO := alarmRulesDO{}

	_alarmRulesDO.alarmRulesDODo.UseDB(db, opts...)
	_alarmRulesDO.alarmRulesDODo.UseModel(&model.AlarmRulesDO{})

	tableName := _alarmRulesDO.alarmRulesDODo.TableName()
	_alarmRulesDO.ALL = field.NewAsterisk(tableName)
	_alarmRulesDO.ID = field.NewInt64(tableName, "id")
	_alarmRulesDO.ModuleID = field.NewInt64(tableName, "module_id")
	_alarmRulesDO.TemplateID = field.NewInt64(tableName, "template_id")
	_alarmRulesDO.TenantID = field.NewInt64(tableName, "tenant_id")
	_alarmRulesDO.ProjectID = field.NewInt64(tableName, "project_id")
	_alarmRulesDO.Name = field.NewString(tableName, "name")
	_alarmRulesDO.Tags = field.NewString(tableName, "tags")
	_alarmRulesDO.SysTags = field.NewString(tableName, "sys_tags")
	_alarmRulesDO.Config = field.NewString(tableName, "config")
	_alarmRulesDO.Level = field.NewString(tableName, "level")
	_alarmRulesDO.State = field.NewString(tableName, "state")
	_alarmRulesDO.RuntimeConfig = field.NewString(tableName, "runtime_config")
	_alarmRulesDO.RunState = field.NewString(tableName, "run_state")
	_alarmRulesDO.RunLastTime = field.NewTime(tableName, "run_last_time")
	_alarmRulesDO.RunNextTime = field.NewTime(tableName, "run_next_time")
	_alarmRulesDO.RunFailureReason = field.NewString(tableName, "run_failure_reason")
	_alarmRulesDO.GenFrom = field.NewString(tableName, "gen_from")
	_alarmRulesDO.Type = field.NewString(tableName, "type")
	_alarmRulesDO.IsDeleted = field.NewInt32(tableName, "is_deleted")
	_alarmRulesDO.CreatedBy = field.NewString(tableName, "created_by")
	_alarmRulesDO.CreateTime = field.NewTime(tableName, "create_time")
	_alarmRulesDO.UpdateTime = field.NewTime(tableName, "update_time")
	_alarmRulesDO.Channels = alarmRulesDOManyToManyChannels{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Channels", "model.AlarmChannelsDO"),
	}

	_alarmRulesDO.fillFieldMap()

	return _alarmRulesDO
}

type alarmRulesDO struct {
	alarmRulesDODo alarmRulesDODo

	ALL              field.Asterisk
	ID               field.Int64 // 自增id
	ModuleID         field.Int64 // 模块id
	TemplateID       field.Int64 // 模板id
	TenantID         field.Int64 // 租户ID
	ProjectID        field.Int64 // 项目ID
	Name             field.String
	Tags             field.String // 用户添加的标签
	SysTags          field.String // 系统添加的标签
	Config           field.String // 规则
	Level            field.String // 级别
	State            field.String // 状态
	RuntimeConfig    field.String // 运行配置
	RunState         field.String
	RunLastTime      field.Time
	RunNextTime      field.Time
	RunFailureReason field.String
	GenFrom          field.String // 创建来源，openapi生成的规则不可变
	Type             field.String // 类型
	IsDeleted        field.Int32  // 是否被删除
	CreatedBy        field.String
	CreateTime       field.Time // 创建时间
	UpdateTime       field.Time // 更新时间
	Channels         alarmRulesDOManyToManyChannels

	fieldMap map[string]field.Expr
}

func (a alarmRulesDO) Table(newTableName string) *alarmRulesDO {
	a.alarmRulesDODo.UseTable(newTableName)
	return a.updateTableName(newTableName)
}

func (a alarmRulesDO) As(alias string) *alarmRulesDO {
	a.alarmRulesDODo.DO = *(a.alarmRulesDODo.As(alias).(*gen.DO))
	return a.updateTableName(alias)
}

func (a *alarmRulesDO) updateTableName(table string) *alarmRulesDO {
	a.ALL = field.NewAsterisk(table)
	a.ID = field.NewInt64(table, "id")
	a.ModuleID = field.NewInt64(table, "module_id")
	a.TemplateID = field.NewInt64(table, "template_id")
	a.TenantID = field.NewInt64(table, "tenant_id")
	a.ProjectID = field.NewInt64(table, "project_id")
	a.Name = field.NewString(table, "name")
	a.Tags = field.NewString(table, "tags")
	a.SysTags = field.NewString(table, "sys_tags")
	a.Config = field.NewString(table, "config")
	a.Level = field.NewString(table, "level")
	a.State = field.NewString(table, "state")
	a.RuntimeConfig = field.NewString(table, "runtime_config")
	a.RunState = field.NewString(table, "run_state")
	a.RunLastTime = field.NewTime(table, "run_last_time")
	a.RunNextTime = field.NewTime(table, "run_next_time")
	a.RunFailureReason = field.NewString(table, "run_failure_reason")
	a.GenFrom = field.NewString(table, "gen_from")
	a.Type = field.NewString(table, "type")
	a.IsDeleted = field.NewInt32(table, "is_deleted")
	a.CreatedBy = field.NewString(table, "created_by")
	a.CreateTime = field.NewTime(table, "create_time")
	a.UpdateTime = field.NewTime(table, "update_time")

	a.fillFieldMap()

	return a
}

func (a *alarmRulesDO) WithContext(ctx context.Context) IAlarmRulesDODo {
	return a.alarmRulesDODo.WithContext(ctx)
}

func (a alarmRulesDO) TableName() string { return a.alarmRulesDODo.TableName() }

func (a alarmRulesDO) Alias() string { return a.alarmRulesDODo.Alias() }

func (a alarmRulesDO) Columns(cols ...field.Expr) gen.Columns {
	return a.alarmRulesDODo.Columns(cols...)
}

func (a *alarmRulesDO) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := a.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (a *alarmRulesDO) fillFieldMap() {
	a.fieldMap = make(map[string]field.Expr, 23)
	a.fieldMap["id"] = a.ID
	a.fieldMap["module_id"] = a.ModuleID
	a.fieldMap["template_id"] = a.TemplateID
	a.fieldMap["tenant_id"] = a.TenantID
	a.fieldMap["project_id"] = a.ProjectID
	a.fieldMap["name"] = a.Name
	a.fieldMap["tags"] = a.Tags
	a.fieldMap["sys_tags"] = a.SysTags
	a.fieldMap["config"] = a.Config
	a.fieldMap["level"] = a.Level
	a.fieldMap["state"] = a.State
	a.fieldMap["runtime_config"] = a.RuntimeConfig
	a.fieldMap["run_state"] = a.RunState
	a.fieldMap["run_last_time"] = a.RunLastTime
	a.fieldMap["run_next_time"] = a.RunNextTime
	a.fieldMap["run_failure_reason"] = a.RunFailureReason
	a.fieldMap["gen_from"] = a.GenFrom
	a.fieldMap["type"] = a.Type
	a.fieldMap["is_deleted"] = a.IsDeleted
	a.fieldMap["created_by"] = a.CreatedBy
	a.fieldMap["create_time"] = a.CreateTime
	a.fieldMap["update_time"] = a.UpdateTime

}

func (a alarmRulesDO) clone(db *gorm.DB) alarmRulesDO {
	a.alarmRulesDODo.ReplaceConnPool(db.Statement.ConnPool)
	a.Channels.db = db.Session(&gorm.Session{Initialized: true})
	a.Channels.db.Statement.ConnPool = db.Statement.ConnPool
	return a
}

func (a alarmRulesDO) replaceDB(db *gorm.DB) alarmRulesDO {
	a.alarmRulesDODo.ReplaceDB(db)
	a.Channels.db = db.Session(&gorm.Session{})
	return a
}

type alarmRulesDOManyToManyChannels struct {
	db *gorm.DB

	field.RelationField
}

func (a alarmRulesDOManyToManyChannels) Where(conds ...field.Expr) *alarmRulesDOManyToManyChannels {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a alarmRulesDOManyToManyChannels) WithContext(ctx context.Context) *alarmRulesDOManyToManyChannels {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a alarmRulesDOManyToManyChannels) Session(session *gorm.Session) *alarmRulesDOManyToManyChannels {
	a.db = a.db.Session(session)
	return &a
}

func (a alarmRulesDOManyToManyChannels) Model(m *model.AlarmRulesDO) *alarmRulesDOManyToManyChannelsTx {
	return &alarmRulesDOManyToManyChannelsTx{a.db.Model(m).Association(a.Name())}
}

func (a alarmRulesDOManyToManyChannels) Unscoped() *alarmRulesDOManyToManyChannels {
	a.db = a.db.Unscoped()
	return &a
}

type alarmRulesDOManyToManyChannelsTx struct{ tx *gorm.Association }

func (a alarmRulesDOManyToManyChannelsTx) Find() (result []*model.AlarmChannelsDO, err error) {
	return result, a.tx.Find(&result)
}

func (a alarmRulesDOManyToManyChannelsTx) Append(values ...*model.AlarmChannelsDO) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a alarmRulesDOManyToManyChannelsTx) Replace(values ...*model.AlarmChannelsDO) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a alarmRulesDOManyToManyChannelsTx) Delete(values ...*model.AlarmChannelsDO) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a alarmRulesDOManyToManyChannelsTx) Clear() error {
	return a.tx.Clear()
}

func (a alarmRulesDOManyToManyChannelsTx) Count() int64 {
	return a.tx.Count()
}

func (a alarmRulesDOManyToManyChannelsTx) Unscoped() *alarmRulesDOManyToManyChannelsTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type alarmRulesDODo struct{ gen.DO }

type IAlarmRulesDODo interface {
	gen.SubQuery
	Debug() IAlarmRulesDODo
	WithContext(ctx context.Context) IAlarmRulesDODo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IAlarmRulesDODo
	WriteDB() IAlarmRulesDODo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IAlarmRulesDODo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IAlarmRulesDODo
	Not(conds ...gen.Condition) IAlarmRulesDODo
	Or(conds ...gen.Condition) IAlarmRulesDODo
	Select(conds ...field.Expr) IAlarmRulesDODo
	Where(conds ...gen.Condition) IAlarmRulesDODo
	Order(conds ...field.Expr) IAlarmRulesDODo
	Distinct(cols ...field.Expr) IAlarmRulesDODo
	Omit(cols ...field.Expr) IAlarmRulesDODo
	Join(table schema.Tabler, on ...field.Expr) IAlarmRulesDODo
	LeftJoin(table schema.Tabler, on ...field.Expr) IAlarmRulesDODo
	RightJoin(table schema.Tabler, on ...field.Expr) IAlarmRulesDODo
	Group(cols ...field.Expr) IAlarmRulesDODo
	Having(conds ...gen.Condition) IAlarmRulesDODo
	Limit(limit int) IAlarmRulesDODo
	Offset(offset int) IAlarmRulesDODo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IAlarmRulesDODo
	Unscoped() IAlarmRulesDODo
	Create(values ...*model.AlarmRulesDO) error
	CreateInBatches(values []*model.AlarmRulesDO, batchSize int) error
	Save(values ...*model.AlarmRulesDO) error
	First() (*model.AlarmRulesDO, error)
	Take() (*model.AlarmRulesDO, error)
	Last() (*model.AlarmRulesDO, error)
	Find() ([]*model.AlarmRulesDO, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.AlarmRulesDO, err error)
	FindInBatches(result *[]*model.AlarmRulesDO, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.AlarmRulesDO) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IAlarmRulesDODo
	Assign(attrs ...field.AssignExpr) IAlarmRulesDODo
	Joins(fields ...field.RelationField) IAlarmRulesDODo
	Preload(fields ...field.RelationField) IAlarmRulesDODo
	FirstOrInit() (*model.AlarmRulesDO, error)
	FirstOrCreate() (*model.AlarmRulesDO, error)
	FindByPage(offset int, limit int) (result []*model.AlarmRulesDO, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IAlarmRulesDODo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (a alarmRulesDODo) Debug() IAlarmRulesDODo {
	return a.withDO(a.DO.Debug())
}

func (a alarmRulesDODo) WithContext(ctx context.Context) IAlarmRulesDODo {
	return a.withDO(a.DO.WithContext(ctx))
}

func (a alarmRulesDODo) ReadDB() IAlarmRulesDODo {
	return a.Clauses(dbresolver.Read)
}

func (a alarmRulesDODo) WriteDB() IAlarmRulesDODo {
	return a.Clauses(dbresolver.Write)
}

func (a alarmRulesDODo) Session(config *gorm.Session) IAlarmRulesDODo {
	return a.withDO(a.DO.Session(config))
}

func (a alarmRulesDODo) Clauses(conds ...clause.Expression) IAlarmRulesDODo {
	return a.withDO(a.DO.Clauses(conds...))
}

func (a alarmRulesDODo) Returning(value interface{}, columns ...string) IAlarmRulesDODo {
	return a.withDO(a.DO.Returning(value, columns...))
}

func (a alarmRulesDODo) Not(conds ...gen.Condition) IAlarmRulesDODo {
	return a.withDO(a.DO.Not(conds...))
}

func (a alarmRulesDODo) Or(conds ...gen.Condition) IAlarmRulesDODo {
	return a.withDO(a.DO.Or(conds...))
}

func (a alarmRulesDODo) Select(conds ...field.Expr) IAlarmRulesDODo {
	return a.withDO(a.DO.Select(conds...))
}

func (a alarmRulesDODo) Where(conds ...gen.Condition) IAlarmRulesDODo {
	return a.withDO(a.DO.Where(conds...))
}

func (a alarmRulesDODo) Order(conds ...field.Expr) IAlarmRulesDODo {
	return a.withDO(a.DO.Order(conds...))
}

func (a alarmRulesDODo) Distinct(cols ...field.Expr) IAlarmRulesDODo {
	return a.withDO(a.DO.Distinct(cols...))
}

func (a alarmRulesDODo) Omit(cols ...field.Expr) IAlarmRulesDODo {
	return a.withDO(a.DO.Omit(cols...))
}

func (a alarmRulesDODo) Join(table schema.Tabler, on ...field.Expr) IAlarmRulesDODo {
	return a.withDO(a.DO.Join(table, on...))
}

func (a alarmRulesDODo) LeftJoin(table schema.Tabler, on ...field.Expr) IAlarmRulesDODo {
	return a.withDO(a.DO.LeftJoin(table, on...))
}

func (a alarmRulesDODo) RightJoin(table schema.Tabler, on ...field.Expr) IAlarmRulesDODo {
	return a.withDO(a.DO.RightJoin(table, on...))
}

func (a alarmRulesDODo) Group(cols ...field.Expr) IAlarmRulesDODo {
	return a.withDO(a.DO.Group(cols...))
}

func (a alarmRulesDODo) Having(conds ...gen.Condition) IAlarmRulesDODo {
	return a.withDO(a.DO.Having(conds...))
}

func (a alarmRulesDODo) Limit(limit int) IAlarmRulesDODo {
	return a.withDO(a.DO.Limit(limit))
}

func (a alarmRulesDODo) Offset(offset int) IAlarmRulesDODo {
	return a.withDO(a.DO.Offset(offset))
}

func (a alarmRulesDODo) Scopes(funcs ...func(gen.Dao) gen.Dao) IAlarmRulesDODo {
	return a.withDO(a.DO.Scopes(funcs...))
}

func (a alarmRulesDODo) Unscoped() IAlarmRulesDODo {
	return a.withDO(a.DO.Unscoped())
}

func (a alarmRulesDODo) Create(values ...*model.AlarmRulesDO) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Create(values)
}

func (a alarmRulesDODo) CreateInBatches(values []*model.AlarmRulesDO, batchSize int) error {
	return a.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (a alarmRulesDODo) Save(values ...*model.AlarmRulesDO) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Save(values)
}

func (a alarmRulesDODo) First() (*model.AlarmRulesDO, error) {
	if result, err := a.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.AlarmRulesDO), nil
	}
}

func (a alarmRulesDODo) Take() (*model.AlarmRulesDO, error) {
	if result, err := a.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.AlarmRulesDO), nil
	}
}

func (a alarmRulesDODo) Last() (*model.AlarmRulesDO, error) {
	if result, err := a.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.AlarmRulesDO), nil
	}
}

func (a alarmRulesDODo) Find() ([]*model.AlarmRulesDO, error) {
	result, err := a.DO.Find()
	return result.([]*model.AlarmRulesDO), err
}

func (a alarmRulesDODo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.AlarmRulesDO, err error) {
	buf := make([]*model.AlarmRulesDO, 0, batchSize)
	err = a.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (a alarmRulesDODo) FindInBatches(result *[]*model.AlarmRulesDO, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return a.DO.FindInBatches(result, batchSize, fc)
}

func (a alarmRulesDODo) Attrs(attrs ...field.AssignExpr) IAlarmRulesDODo {
	return a.withDO(a.DO.Attrs(attrs...))
}

func (a alarmRulesDODo) Assign(attrs ...field.AssignExpr) IAlarmRulesDODo {
	return a.withDO(a.DO.Assign(attrs...))
}

func (a alarmRulesDODo) Joins(fields ...field.RelationField) IAlarmRulesDODo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Joins(_f))
	}
	return &a
}

func (a alarmRulesDODo) Preload(fields ...field.RelationField) IAlarmRulesDODo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Preload(_f))
	}
	return &a
}

func (a alarmRulesDODo) FirstOrInit() (*model.AlarmRulesDO, error) {
	if result, err := a.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.AlarmRulesDO), nil
	}
}

func (a alarmRulesDODo) FirstOrCreate() (*model.AlarmRulesDO, error) {
	if result, err := a.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.AlarmRulesDO), nil
	}
}

func (a alarmRulesDODo) FindByPage(offset int, limit int) (result []*model.AlarmRulesDO, count int64, err error) {
	result, err = a.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = a.Offset(-1).Limit(-1).Count()
	return
}

func (a alarmRulesDODo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	err = a.Offset(offset).Limit(limit).Scan(result)
	return
}

func (a alarmRulesDODo) Scan(result interface{}) (err error) {
	return a.DO.Scan(result)
}

func (a alarmRulesDODo) Delete(models ...*model.AlarmRulesDO) (result gen.ResultInfo, err error) {
	return a.DO.Delete(models)
}

func (a *alarmRulesDODo) withDO(do gen.Dao) *alarmRulesDODo {
	a.DO = *do.(*gen.DO)
	return a
}
