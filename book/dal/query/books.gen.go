// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"
	"strings"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"test/book/dal/model"
)

func newBooksDO(db *gorm.DB, opts ...gen.DOOption) booksDO {
	_booksDO := booksDO{}

	_booksDO.booksDODo.UseDB(db, opts...)
	_booksDO.booksDODo.UseModel(&model.BooksDO{})

	tableName := _booksDO.booksDODo.TableName()
	_booksDO.ALL = field.NewAsterisk(tableName)
	_booksDO.ID = field.NewInt64(tableName, "id")
	_booksDO.Title = field.NewString(tableName, "title")
	_booksDO.Author = field.NewString(tableName, "author")
	_booksDO.Price = field.NewInt32(tableName, "price")
	_booksDO.PublishDate = field.NewTime(tableName, "publish_date")
	_booksDO.Users = booksDOManyToManyUsers{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Users", "model.UsersDO"),
		Books: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Users.Books", "model.BooksDO"),
		},
	}

	_booksDO.fillFieldMap()

	return _booksDO
}

// booksDO 书籍表
type booksDO struct {
	booksDODo booksDODo

	ALL         field.Asterisk
	ID          field.Int64  // 主键
	Title       field.String // 书籍名称
	Author      field.String // 作者
	Price       field.Int32  // 价格
	PublishDate field.Time   // 出版日期
	Users       booksDOManyToManyUsers

	fieldMap map[string]field.Expr
}

func (b booksDO) Table(newTableName string) *booksDO {
	b.booksDODo.UseTable(newTableName)
	return b.updateTableName(newTableName)
}

func (b booksDO) As(alias string) *booksDO {
	b.booksDODo.DO = *(b.booksDODo.As(alias).(*gen.DO))
	return b.updateTableName(alias)
}

func (b *booksDO) updateTableName(table string) *booksDO {
	b.ALL = field.NewAsterisk(table)
	b.ID = field.NewInt64(table, "id")
	b.Title = field.NewString(table, "title")
	b.Author = field.NewString(table, "author")
	b.Price = field.NewInt32(table, "price")
	b.PublishDate = field.NewTime(table, "publish_date")

	b.fillFieldMap()

	return b
}

func (b *booksDO) WithContext(ctx context.Context) IBooksDODo { return b.booksDODo.WithContext(ctx) }

func (b booksDO) TableName() string { return b.booksDODo.TableName() }

func (b booksDO) Alias() string { return b.booksDODo.Alias() }

func (b booksDO) Columns(cols ...field.Expr) gen.Columns { return b.booksDODo.Columns(cols...) }

func (b *booksDO) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := b.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (b *booksDO) fillFieldMap() {
	b.fieldMap = make(map[string]field.Expr, 6)
	b.fieldMap["id"] = b.ID
	b.fieldMap["title"] = b.Title
	b.fieldMap["author"] = b.Author
	b.fieldMap["price"] = b.Price
	b.fieldMap["publish_date"] = b.PublishDate

}

func (b booksDO) clone(db *gorm.DB) booksDO {
	b.booksDODo.ReplaceConnPool(db.Statement.ConnPool)
	b.Users.db = db.Session(&gorm.Session{Initialized: true})
	b.Users.db.Statement.ConnPool = db.Statement.ConnPool
	return b
}

func (b booksDO) replaceDB(db *gorm.DB) booksDO {
	b.booksDODo.ReplaceDB(db)
	b.Users.db = db.Session(&gorm.Session{})
	return b
}

type booksDOManyToManyUsers struct {
	db *gorm.DB

	field.RelationField

	Books struct {
		field.RelationField
	}
}

func (a booksDOManyToManyUsers) Where(conds ...field.Expr) *booksDOManyToManyUsers {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a booksDOManyToManyUsers) WithContext(ctx context.Context) *booksDOManyToManyUsers {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a booksDOManyToManyUsers) Session(session *gorm.Session) *booksDOManyToManyUsers {
	a.db = a.db.Session(session)
	return &a
}

func (a booksDOManyToManyUsers) Model(m *model.BooksDO) *booksDOManyToManyUsersTx {
	return &booksDOManyToManyUsersTx{a.db.Model(m).Association(a.Name())}
}

func (a booksDOManyToManyUsers) Unscoped() *booksDOManyToManyUsers {
	a.db = a.db.Unscoped()
	return &a
}

type booksDOManyToManyUsersTx struct{ tx *gorm.Association }

func (a booksDOManyToManyUsersTx) Find() (result []*model.UsersDO, err error) {
	return result, a.tx.Find(&result)
}

func (a booksDOManyToManyUsersTx) Append(values ...*model.UsersDO) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a booksDOManyToManyUsersTx) Replace(values ...*model.UsersDO) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a booksDOManyToManyUsersTx) Delete(values ...*model.UsersDO) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a booksDOManyToManyUsersTx) Clear() error {
	return a.tx.Clear()
}

func (a booksDOManyToManyUsersTx) Count() int64 {
	return a.tx.Count()
}

func (a booksDOManyToManyUsersTx) Unscoped() *booksDOManyToManyUsersTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type booksDODo struct{ gen.DO }

type IBooksDODo interface {
	gen.SubQuery
	Debug() IBooksDODo
	WithContext(ctx context.Context) IBooksDODo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IBooksDODo
	WriteDB() IBooksDODo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IBooksDODo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IBooksDODo
	Not(conds ...gen.Condition) IBooksDODo
	Or(conds ...gen.Condition) IBooksDODo
	Select(conds ...field.Expr) IBooksDODo
	Where(conds ...gen.Condition) IBooksDODo
	Order(conds ...field.Expr) IBooksDODo
	Distinct(cols ...field.Expr) IBooksDODo
	Omit(cols ...field.Expr) IBooksDODo
	Join(table schema.Tabler, on ...field.Expr) IBooksDODo
	LeftJoin(table schema.Tabler, on ...field.Expr) IBooksDODo
	RightJoin(table schema.Tabler, on ...field.Expr) IBooksDODo
	Group(cols ...field.Expr) IBooksDODo
	Having(conds ...gen.Condition) IBooksDODo
	Limit(limit int) IBooksDODo
	Offset(offset int) IBooksDODo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IBooksDODo
	Unscoped() IBooksDODo
	Create(values ...*model.BooksDO) error
	CreateInBatches(values []*model.BooksDO, batchSize int) error
	Save(values ...*model.BooksDO) error
	First() (*model.BooksDO, error)
	Take() (*model.BooksDO, error)
	Last() (*model.BooksDO, error)
	Find() ([]*model.BooksDO, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.BooksDO, err error)
	FindInBatches(result *[]*model.BooksDO, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.BooksDO) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IBooksDODo
	Assign(attrs ...field.AssignExpr) IBooksDODo
	Joins(fields ...field.RelationField) IBooksDODo
	Preload(fields ...field.RelationField) IBooksDODo
	FirstOrInit() (*model.BooksDO, error)
	FirstOrCreate() (*model.BooksDO, error)
	FindByPage(offset int, limit int) (result []*model.BooksDO, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IBooksDODo
	UnderlyingDB() *gorm.DB
	schema.Tabler

	GetByID(id int) (result model.BooksDO, err error)
	GetByIDReturnMap(ids []int) (result []map[string]interface{}, err error)
	GetBooksByAuthor(author string) (result []*model.BooksDO, err error)
	FilterWithColumn(column string, value string) (result []model.BooksDO, err error)
	Search(book *model.BooksDO) (result []*model.BooksDO, err error)
}

// GetByID
// SELECT * FROM @@table WHERE id=@id
func (b booksDODo) GetByID(id int) (result model.BooksDO, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, id)
	generateSQL.WriteString("SELECT * FROM books WHERE id=? ")

	var executeSQL *gorm.DB
	executeSQL = b.UnderlyingDB().Raw(generateSQL.String(), params...).Take(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// GetByIDReturnMap
// SELECT * FROM @@table WHERE id in @ids
func (b booksDODo) GetByIDReturnMap(ids []int) (result []map[string]interface{}, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, ids)
	generateSQL.WriteString("SELECT * FROM books WHERE id in ? ")

	var executeSQL *gorm.DB
	executeSQL = b.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// GetBooksByAuthor
// SELECT * FROM @@table WHERE author=@author
func (b booksDODo) GetBooksByAuthor(author string) (result []*model.BooksDO, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, author)
	generateSQL.WriteString("SELECT * FROM books WHERE author=? ")

	var executeSQL *gorm.DB
	executeSQL = b.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// FilterWithColumn
// SELECT * FROM @@table WHERE @@column=@value
func (b booksDODo) FilterWithColumn(column string, value string) (result []model.BooksDO, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, value)
	generateSQL.WriteString("SELECT * FROM books WHERE " + b.Quote(column) + "=? ")

	var executeSQL *gorm.DB
	executeSQL = b.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// Search 根据指定条件查询书籍
//
// SELECT * FROM book
// WHERE publish_date is not null
// {{if book != nil}}
//
//	{{if book.ID > 0}}
//	  AND id = @book.ID
//	{{else if book.Author != ""}}
//	  AND author=@book.Author
//	{{end}}
//
// {{end}}
func (b booksDODo) Search(book *model.BooksDO) (result []*model.BooksDO, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	generateSQL.WriteString("SELECT * FROM book WHERE publish_date is not null ")
	if book != nil {
		if book.ID > 0 {
			params = append(params, book.ID)
			generateSQL.WriteString("AND id = ? ")
		} else if book.Author != "" {
			params = append(params, book.Author)
			generateSQL.WriteString("AND author=? ")
		}
	}

	var executeSQL *gorm.DB
	executeSQL = b.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

func (b booksDODo) Debug() IBooksDODo {
	return b.withDO(b.DO.Debug())
}

func (b booksDODo) WithContext(ctx context.Context) IBooksDODo {
	return b.withDO(b.DO.WithContext(ctx))
}

func (b booksDODo) ReadDB() IBooksDODo {
	return b.Clauses(dbresolver.Read)
}

func (b booksDODo) WriteDB() IBooksDODo {
	return b.Clauses(dbresolver.Write)
}

func (b booksDODo) Session(config *gorm.Session) IBooksDODo {
	return b.withDO(b.DO.Session(config))
}

func (b booksDODo) Clauses(conds ...clause.Expression) IBooksDODo {
	return b.withDO(b.DO.Clauses(conds...))
}

func (b booksDODo) Returning(value interface{}, columns ...string) IBooksDODo {
	return b.withDO(b.DO.Returning(value, columns...))
}

func (b booksDODo) Not(conds ...gen.Condition) IBooksDODo {
	return b.withDO(b.DO.Not(conds...))
}

func (b booksDODo) Or(conds ...gen.Condition) IBooksDODo {
	return b.withDO(b.DO.Or(conds...))
}

func (b booksDODo) Select(conds ...field.Expr) IBooksDODo {
	return b.withDO(b.DO.Select(conds...))
}

func (b booksDODo) Where(conds ...gen.Condition) IBooksDODo {
	return b.withDO(b.DO.Where(conds...))
}

func (b booksDODo) Order(conds ...field.Expr) IBooksDODo {
	return b.withDO(b.DO.Order(conds...))
}

func (b booksDODo) Distinct(cols ...field.Expr) IBooksDODo {
	return b.withDO(b.DO.Distinct(cols...))
}

func (b booksDODo) Omit(cols ...field.Expr) IBooksDODo {
	return b.withDO(b.DO.Omit(cols...))
}

func (b booksDODo) Join(table schema.Tabler, on ...field.Expr) IBooksDODo {
	return b.withDO(b.DO.Join(table, on...))
}

func (b booksDODo) LeftJoin(table schema.Tabler, on ...field.Expr) IBooksDODo {
	return b.withDO(b.DO.LeftJoin(table, on...))
}

func (b booksDODo) RightJoin(table schema.Tabler, on ...field.Expr) IBooksDODo {
	return b.withDO(b.DO.RightJoin(table, on...))
}

func (b booksDODo) Group(cols ...field.Expr) IBooksDODo {
	return b.withDO(b.DO.Group(cols...))
}

func (b booksDODo) Having(conds ...gen.Condition) IBooksDODo {
	return b.withDO(b.DO.Having(conds...))
}

func (b booksDODo) Limit(limit int) IBooksDODo {
	return b.withDO(b.DO.Limit(limit))
}

func (b booksDODo) Offset(offset int) IBooksDODo {
	return b.withDO(b.DO.Offset(offset))
}

func (b booksDODo) Scopes(funcs ...func(gen.Dao) gen.Dao) IBooksDODo {
	return b.withDO(b.DO.Scopes(funcs...))
}

func (b booksDODo) Unscoped() IBooksDODo {
	return b.withDO(b.DO.Unscoped())
}

func (b booksDODo) Create(values ...*model.BooksDO) error {
	if len(values) == 0 {
		return nil
	}
	return b.DO.Create(values)
}

func (b booksDODo) CreateInBatches(values []*model.BooksDO, batchSize int) error {
	return b.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (b booksDODo) Save(values ...*model.BooksDO) error {
	if len(values) == 0 {
		return nil
	}
	return b.DO.Save(values)
}

func (b booksDODo) First() (*model.BooksDO, error) {
	if result, err := b.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.BooksDO), nil
	}
}

func (b booksDODo) Take() (*model.BooksDO, error) {
	if result, err := b.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.BooksDO), nil
	}
}

func (b booksDODo) Last() (*model.BooksDO, error) {
	if result, err := b.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.BooksDO), nil
	}
}

func (b booksDODo) Find() ([]*model.BooksDO, error) {
	result, err := b.DO.Find()
	return result.([]*model.BooksDO), err
}

func (b booksDODo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.BooksDO, err error) {
	buf := make([]*model.BooksDO, 0, batchSize)
	err = b.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (b booksDODo) FindInBatches(result *[]*model.BooksDO, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return b.DO.FindInBatches(result, batchSize, fc)
}

func (b booksDODo) Attrs(attrs ...field.AssignExpr) IBooksDODo {
	return b.withDO(b.DO.Attrs(attrs...))
}

func (b booksDODo) Assign(attrs ...field.AssignExpr) IBooksDODo {
	return b.withDO(b.DO.Assign(attrs...))
}

func (b booksDODo) Joins(fields ...field.RelationField) IBooksDODo {
	for _, _f := range fields {
		b = *b.withDO(b.DO.Joins(_f))
	}
	return &b
}

func (b booksDODo) Preload(fields ...field.RelationField) IBooksDODo {
	for _, _f := range fields {
		b = *b.withDO(b.DO.Preload(_f))
	}
	return &b
}

func (b booksDODo) FirstOrInit() (*model.BooksDO, error) {
	if result, err := b.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.BooksDO), nil
	}
}

func (b booksDODo) FirstOrCreate() (*model.BooksDO, error) {
	if result, err := b.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.BooksDO), nil
	}
}

func (b booksDODo) FindByPage(offset int, limit int) (result []*model.BooksDO, count int64, err error) {
	result, err = b.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = b.Offset(-1).Limit(-1).Count()
	return
}

func (b booksDODo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = b.Count()
	if err != nil {
		return
	}

	err = b.Offset(offset).Limit(limit).Scan(result)
	return
}

func (b booksDODo) Scan(result interface{}) (err error) {
	return b.DO.Scan(result)
}

func (b booksDODo) Delete(models ...*model.BooksDO) (result gen.ResultInfo, err error) {
	return b.DO.Delete(models)
}

func (b *booksDODo) withDO(do gen.Dao) *booksDODo {
	b.DO = *do.(*gen.DO)
	return b
}
